        -:    0:Source:bitarray.c
        -:    0:Graph:bitarray.gcno
        -:    0:Data:bitarray.gcda
        -:    0:Runs:1
        -:    1:#include "bitarray.h"
        -:    2:
        1:    3:void Construct (bitarr_t *bitarr, size_t capacity) {
        1:    4:	bitarr->array = (uint64_t *) calloc (DEFAULT_CAPACITY, sizeof (uint64_t));
        1:    5:	bitarr->capacity = capacity;
        1:    6:	bitarr->size = 0;
        1:    7:	return;
        -:    8:}
        -:    9:
        1:   10:void Reset (bitarr_t *bitarr) {
        3:   11:	for (ssize_t i = 0; i < bitarr->capacity / ELEMENT_SIZE; i++) {
        2:   12:		bitarr->array[i] = 0;
        -:   13:	}
        1:   14:	bitarr->size = 0;
        1:   15:	return;
        -:   16:}
        -:   17:
    #####:   18:void ResizeUP (bitarr_t *bitarr, size_t extra) {
    #####:   19:	bitarr->array = (uint64_t *) realloc (bitarr->array, (bitarr->capacity + extra) / ELEMENT_SIZE + 1);
    #####:   20:	bitarr->capacity += (extra / ELEMENT_SIZE + 1) * ELEMENT_SIZE;
    #####:   21:	return;
        -:   22:}
        -:   23:
    #####:   24:void ResizeDown (bitarr_t *bitarr, size_t extra) {
    #####:   25:	bitarr->array = (uint64_t *) realloc (bitarr->array, (bitarr->capacity - extra) / ELEMENT_SIZE + 1);
    #####:   26:	bitarr->capacity -= extra;
    #####:   27:	return;
        -:   28:}
        -:   29:
    #####:   30:int GetBit (bitarr_t *bitarr, size_t pos) {
    #####:   31:	if (pos >= bitarr->capacity)
    #####:   32:		return INVALID_POS;
        -:   33:
    #####:   34:	uint64_t mask = 1;
    #####:   35:	mask = mask << pos % ELEMENT_SIZE;
    #####:   36:	if (bitarr->array[pos / ELEMENT_SIZE] & mask)
    #####:   37:		return 1;
    #####:   38:	return 0;
        -:   39:}
        -:   40:
       19:   41:int SetBit (bitarr_t *bitarr, size_t pos, bit_t bit) {
       19:   42:	if (pos >= bitarr->capacity) {
    #####:   43:		ResizeUP (bitarr, pos - bitarr->capacity);
        -:   44:	}
        -:   45:
       19:   46:	uint64_t *point = bitarr->array + pos / ELEMENT_SIZE; 
       19:   47:	uint64_t mask = 1;
       19:   48:	mask = mask << (pos % ELEMENT_SIZE);
        -:   49:
       19:   50:	if (bit == SET) {
       19:   51:		*point = *point | mask;
       19:   52:		return 0;
        -:   53:	}
    #####:   54:	if (bit == UNSET) {
    #####:   55:		mask = ~mask;
    #####:   56:		*point = *point & mask;
    #####:   57:		return 0;
        -:   58:	}
    #####:   59:	return -1;
        -:   60:}
        -:   61:
    #####:   62:int FindFirstSet (bitarr_t *bitarr) {
    #####:   63:	size_t result = 0;
    #####:   64:	size_t i = 0;
    #####:   65:	for (i = 0; i < bitarr->capacity; i++) {
    #####:   66:		if (bitarr->array[i])
    #####:   67:			break;
    #####:   68:		result += ELEMENT_SIZE;
        -:   69:	}
        -:   70:
    #####:   71:	uint64_t current = bitarr->array[i];
        -:   72:	
    #####:   73:	for (int offset = 0; offset < ELEMENT_SIZE; i++) {
    #####:   74:		if (current & (1 << offset))
    #####:   75:			break;
    #####:   76:		result++;
        -:   77:	}
    #####:   78:	return result;
        -:   79:}
        -:   80:
        1:   81:void Dump (bitarr_t *bitarr, const char *pathname) {
        1:   82:	FILE *dumpfile = fopen (pathname, "w+");
        1:   83:	fprintf (dumpfile, "BitArray %s\n", TimeNow ());
        1:   84:	uint64_t mask = 1;
        3:   85:	for (size_t i = 0; i < bitarr->capacity / ELEMENT_SIZE; i++) {
        2:   86:		fprintf (dumpfile, "[%ld] =", i);
      130:   87:		for (size_t offset = 0; offset < ELEMENT_SIZE; offset++) {
      128:   88:			if (!(offset % 4)) fprintf (dumpfile, " ");
      128:   89:			if (bitarr->array[i] & (mask << offset)) fprintf (dumpfile, "1");
      109:   90:			else fprintf (dumpfile, "0");
        -:   91:		}
        2:   92:		fprintf (dumpfile, "\n");
        -:   93:	}
        1:   94:	return;
        -:   95:}
        -:   96:
        1:   97:char *TimeNow () {
        1:   98:	time_t t = time (NULL);
        1:   99:	return asctime (localtime (&t));
        -:  100:}
